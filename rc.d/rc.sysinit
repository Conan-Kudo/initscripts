#!/bin/sh
#
# /etc/rc.sysinit - run once at boot time
#
# Taken in part from Miquel van Smoorenburg's bcheckrc.
#

# Rerun ourselves through initlog
if [ -z "$IN_INITLOG" ]; then
 [ -f /sbin/initlog ] && exec /sbin/initlog $INITLOG_ARGS -r /etc/rc.sysinit
fi

# If we're using devfs, start devfsd now - we need the old device names
[ -e /dev/.devfsd -a -x /sbin/devfsd ] && /sbin/devfsd /dev

# Set the path
PATH=/bin:/sbin:/usr/bin:/usr/sbin
export PATH

HOSTNAME=`/bin/hostname`

# Read in config data.
if [ -f /etc/sysconfig/network ]; then
    . /etc/sysconfig/network
else
    NETWORKING=no
fi

if [ -z "$HOSTNAME" -o "$HOSTNAME" = "(none)" ]; then
    HOSTNAME=localhost
fi

# Source functions
. /etc/init.d/functions

# Print a banner. ;)
echo -en "\t\t\tWelcome to "
[ "$BOOTUP" != "serial" ] && echo -en "\\033[1;31m"
echo -en "Red Hat"
[ "$BOOTUP" != "serial" ] && echo -en "\\033[0;39m"
echo " Linux"
if [ "$PROMPT" != "no" ]; then
 echo -en "\t\tPress 'I' to enter interactive startup."
 echo
 sleep 1
fi

# Fix console loglevel
/bin/dmesg -n $LOGLEVEL

# Mount /proc (done here so volume labels can work with fsck)

action "Mounting proc filesystem: " mount -n -t proc /proc /proc

# Configure kernel parameters

action "Configuring kernel parameters: " sysctl -p /etc/sysctl.conf

# Set the system clock.
ARC=0
SRM=0
UTC=0

if [ -f /etc/sysconfig/clock ]; then
   . /etc/sysconfig/clock

   # convert old style clock config to new values
   if [ "${CLOCKMODE}" = "GMT" ]; then
      UTC=true
   elif [ "${CLOCKMODE}" = "ARC" ]; then
      ARC=true
   fi
fi

CLOCKDEF=""
CLOCKFLAGS="--hctosys"

case "$UTC" in
   yes|true)
    CLOCKFLAGS="$CLOCKFLAGS -u";
    CLOCKDEF="$CLOCKDEF (utc)";
   ;;
   no|false)
    CLOCKFLAGS="$CLOCKFLAGS --localtime";
    CLOCKDEF="$CLOCKDEF (localtime)";
   ;;
esac

case "$ARC" in
     yes|true)
     	CLOCKFLAGS="$CLOCKFLAGS -A";
     	CLOCKDEF="$CLOCKDEF (arc)";
     ;;
esac
case "$SRM" in
     yes|true)
	CLOCKFLAGS="$CLOCKFLAGS -S";
	CLOCKDEF="$CLOCKDEF (srm)";
     ;;
esac

/sbin/hwclock $CLOCKFLAGS

action "Setting clock $CLOCKDEF: `date`" date

if [ "`/sbin/consoletype`" == "vt" ]; then
 # Load keymap
 if [ -x /bin/loadkeys ]; then
 KEYTABLE=
 KEYMAP=
 if [ -f /etc/sysconfig/console/default.kmap ]; then
  KEYMAP=/etc/sysconfig/console/default.kmap
 else
  if [ -f /etc/sysconfig/keyboard ]; then
    . /etc/sysconfig/keyboard
  fi
  if [ -n "$KEYTABLE" -a -d "/usr/lib/kbd/keymaps" -o -d "/lib/kbd/keymaps" ]; then
     KEYMAP=$KEYTABLE
  fi
 fi
 if [ -n "$KEYMAP" ]; then 
  # Since this takes in/output from stdin/out, we can't use initlog
  if [ -n "$KEYTABLE" ]; then
    echo -n "Loading default keymap ($KEYTABLE): "
  else
    echo -n "Loading default keymap: "
  fi
  loadkeys $KEYMAP < /dev/tty0 > /dev/tty0 2>/dev/null && \
     success "Loading default keymap" || failure "Loading default keymap"
  echo
 fi   
 fi

 # Load system font
 if [ -x /sbin/setsysfont ]; then
    [ -f /etc/sysconfig/i18n ] && . /etc/sysconfig/i18n
    if [ -f /etc/sysconfig/console/$SYSFONT.psf.gz -o \
         -f /usr/lib/kbd/consolefonts/$SYSFONT.psf.gz -o \
         -f /etc/sysconfig/console/$SYSFONT.gz -o \
         -f /usr/lib/kbd/consolefonts/$SYSFONT.gz -o \
	 -f /lib/kbd/consolefonts/$SYSFONT.gz -o \
	 -f /lib/kbd/consolefonts/$SYSFONT.psf.gz ]; then
       action "Setting default font ($SYSFONT): " /sbin/setsysfont
    fi
 fi
fi

# Start up swapping.
action "Activating swap partitions: " swapon -a

# Set the hostname.
action "Setting hostname ${HOSTNAME}: " hostname ${HOSTNAME}

# Set the NIS domain name
if [ -n "$NISDOMAIN" ]; then
    action "Setting NIS domain name $NISDOMAIN: " domainname $NISDOMAIN
else
    domainname ""
fi

# Initialize USB controller and HID devices
usb=0
if ! grep -iq "nousb" /proc/cmdline 2>/dev/null && ! grep -q "usb" /proc/devices 2>/dev/null ; then
    aliases=`/sbin/modprobe -c | egrep -s "^alias[[:space:]]+usb-controller" | awk '{ print $3 }'`
    if [ -n "$aliases" -a "$aliases" != "off" ] ; then
      modprobe usbcore
      action "Mounting USB filesystem: "  mount -t usbdevfs usbdevfs /proc/bus/usb
      for alias in $aliases ; do 
      	action "Initializing USB controller ($alias): " modprobe $alias
      done
      [ $? -eq 0 -a -n "$aliases" ] && usb=1
    fi
fi

if ! grep -iq "nousb" /proc/cmdline 2>/dev/null && grep -q "usb" /proc/devices 2>/dev/null ; then
  usb=1
fi

needusbstorage=
if [ $usb = "1" ]; then
    sleep 5
    mouseoutput=`cat /proc/bus/usb/devices 2>/dev/null|grep -E "^I.*Cls=03.*Prot=02"`
    kbdoutput=`cat /proc/bus/usb/devices 2>/dev/null|grep -E "^I.*Cls=03.*Prot=01"`
    needusbstorage=`cat /proc/bus/usb/devices 2>/dev/null|grep -e "^I.*Cls=08"`
    if [ -n "$kbdoutput" ] || [ -n "$mouseoutput" ]; then
	action "Initializing USB HID interface: " modprobe hid 2> /dev/null
    fi
    if [ -n "$kbdoutput" ]; then
	action "Initializing USB keyboard: " modprobe keybdev
    fi
    if [ -n "$mouseoutput" ]; then
	action "Initializing USB mouse: " modprobe mousedev
    fi
fi

if [ -f /fastboot ] || grep -iq "fastboot" /proc/cmdline 2>/dev/null ; then
	fastboot=yes
    else
        fastboot=
fi

if [ -f /fsckoptions ]; then
	fsckoptions=`cat /fsckoptions`
    else
	fsckoptions=
fi

if [ -f /forcefsck ]; then
	fsckoptions="-f $fsckoptions"
fi

if [ "$BOOTUP" != "serial" ]; then
	fsckoptions="-C $fsckoptions"
else
	fsckoptions="-V $fsckoptions"
fi

_RUN_QUOTACHECK=0
ROOTFSTYPE=`grep " / " /proc/mounts | awk '{ print $3 }'`
if [ -z "$fastboot" -a "$ROOTFSTYPE" != "nfs" ]; then 

        STRING="Checking root filesystem"
	echo $STRING
	initlog -c "fsck -T -a $fsckoptions /"
	rc=$?
	
	if [ "$rc" = "0" ]; then
		success "$STRING"
		echo
	elif [ "$rc" = "1" ]; then
	        passed "$STRING"
		echo
        fi
	
        # A return of 2 or higher means there were serious problems.
	if [ $rc -gt 1 ]; then
		failure "$STRING"
		echo
		echo
		echo "*** An error occurred during the file system check."
		echo "*** Dropping you to a shell; the system will reboot"
		echo "*** when you leave the shell."

		PS1="(Repair filesystem) \# # "; export PS1
		sulogin

		echo "Unmounting file systems"
		umount -a
		mount -n -o remount,ro /
		echo "Automatic reboot in progress."
		reboot -f
	elif [ "$rc" = "1" ]; then
		_RUN_QUOTACHECK=1
	fi
fi

# check for arguments 

if grep -iq nopnp /proc/cmdline >/dev/null 2>&1 ; then
    PNP=
else
    PNP=yes
fi

# set up pnp 
if [ -x /sbin/isapnp -a -f /etc/isapnp.conf -a ! -f /proc/isapnp ]; then
    if [ -n "$PNP" ]; then
	action "Setting up ISA PNP devices: " /sbin/isapnp /etc/isapnp.conf
    else
	action "Skipping ISA PNP configuration at users request: " /bin/true
    fi
fi

# Remount the root filesystem read-write.
state=`awk '/(^\/dev\/root| \/ )/ { print $4 }' /proc/mounts`
[ "$state" != "rw" ] && \
  action "Remounting root filesystem in read-write mode: " mount -n -o remount,rw /

# Clear mtab
>/etc/mtab

# Remove stale backups
rm -f /etc/mtab~ /etc/mtab~~

# Enter root, /proc and (potentially) /proc/bus/usb and devfs into mtab.
mount -f /
mount -f /proc
[ -f /proc/bus/usb/devices ] && mount -f -t usbdevfs usbdevfs /proc/bus/usb
[ -e /dev/.devfsd ] && mount -f -t devfs devfs /dev 

# Turn on harddisk optimization
if [ -f /etc/sysconfig/harddisks ]  && [ -x /sbin/hdparm ]; then
    . /etc/sysconfig/harddisks
    HDFLAGS=
    if [ -n "$MULTIPLE_IO" ] && [ "$MULTIPLE_IO" != "0" ]; then
	HDFLAGS="-q -m$MULTIPLE_IO"
    fi
    if [ -n "$USE_DMA" ] && [ "$USE_DMA" != "0" ]; then
	HDFLAGS="$HDFLAGS -q -d$USE_DMA"
    fi
    if [ -n "$EIDE_32BIT" ]; then
	HDFLAGS="$HDFLAGS -q -c$EIDE_32BIT"
    fi
    if [ -n "$LOOKAHEAD" ]; then
	HDFLAGS="$HDFLAGS -q -A$LOOKAHEAD"
    fi
    if [ -n "$EXTRA_PARAMS" ]; then
	HDFLAGS="$HDFLAGS $EXTRA_PARAMS"
    fi
    if [ -n "$HDFLAGS" ]; then
   	for i in a b c d e f g h ; do
	    if [ -e "/proc/ide/hd$i/media" ] ; then
		hdmedia=`cat /proc/ide/hd$i/media`
		if [ "$hdmedia" = "disk" ]; then
	   		action "Setting hard drive parameters for hd$i: "  /sbin/hdparm $HDFLAGS /dev/hd$i
		fi
	    fi
 	done
    fi
fi    

# Update quotas if fsck was run on /.
if [ X"$_RUN_QUOTACHECK" = X1 -a -x /sbin/quotacheck ]; then
	action "Checking root filesystem quotas: "  /sbin/quotacheck -v /
fi

# The root filesystem is now read-write, so we can now log via syslog() directly..
if [ -n "$IN_INITLOG" ]; then
    IN_INITLOG=
fi

if ! grep -iq nomodules /proc/cmdline >/dev/null 2>&1 && [ -f /proc/ksyms ]; then
    USEMODULES=y
else
    USEMODULES=
fi

# Our modutils don't support it anymore, so we might as well remove
# the preferred link.
rm -f /lib/modules/preferred
rm -f /lib/modules/default
if [ -x /sbin/depmod -a -n "$USEMODULES" ]; then
    # If they aren't using a recent sane kernel, make a link for them
    if [ ! -n "`uname -r | grep -- "-"`" ]; then
       ktag="`cat /proc/version`"
       mtag=`grep -l "$ktag" /lib/modules/*/.rhkmvtag 2> /dev/null`
       if [ -n "$mtag" ]; then
          mver=`echo $mtag | sed -e 's,/lib/modules/,,' -e 's,/.rhkmvtag,,' -e 's,[       ].*$,,'`
       fi
       if [ -n "$mver" ]; then
         ln -sf /lib/modules/$mver /lib/modules/default
       fi
    fi
    if [ -L /lib/modules/default ]; then
    	INITLOG_ARGS= action "Finding module dependencies: " depmod -A default
    else
	INITLOG_ARGS= action "Finding module dependencies: " depmod -A
    fi
fi

# Load sound modules
#
# I think this now qualifies as over-engineered.
RETURN=0
alias=`/sbin/modprobe -c | egrep -s "^alias[[:space:]]+sound[[:space:]]+" | awk '{ print $3 }'`
if [ -n "$alias" -a "$alias" != "off" ] ; then
      action "Loading sound module ($alias): " modprobe $alias
      RETURN=$?
fi
alias=`/sbin/modprobe -c | egrep -s "^alias[[:space:]]+sound-slot-0[[:space:]]+" | awk '{ print $3 }'`
if [ -n "$alias" -a "$alias" != "off" ] ; then
      action "Loading sound module ($alias): " modprobe $alias
      RETURN=$?
fi
alias=`/sbin/modprobe -c | egrep -s "^alias[[:space:]]+midi[[:space:]]+" | awk '{ print $3 }'`
if [ -n "$alias" -a "$alias" != "off" ]; then
      action "Loading midi module ($alias): " modprobe $alias
fi

# Load mixer settings
if grep -q "\(sparcaudio\|sound\)" /proc/devices 2>/dev/null ; then
     if [ $RETURN -eq 0 -a -f /etc/.aumixrc -a -x /bin/aumix-minimal ]; then
	action "Loading mixer settings: " /bin/aumix-minimal -f /etc/.aumixrc -L
     fi
fi

if [ -f /proc/sys/kernel/modprobe ]; then
   if [ -n "$USEMODULES" ]; then
       sysctl -w kernel.modprobe="/sbin/modprobe" >/dev/null 2>&1
       sysctl -w kernel.hotplug="/sbin/hotplug" >/dev/null 2>&1
   else
       # We used to set this to NULL, but that causes 'failed to exec' messages"
       sysctl -w kernel.modprobe="/bin/true" >/dev/null 2>&1
       sysctl -w kernel.hotplug="/bin/true" >/dev/null 2>&1
   fi
fi

# Load modules (for backward compatibility with VARs)
if [ -f /etc/rc.modules ]; then
	/etc/rc.modules
fi

# Add raid devices
if [ ! -f /proc/mdstat ]; then
	modprobe md >/dev/null 2>&1
fi	

if [ -f /proc/mdstat -a -f /etc/raidtab ]; then
	echo -n "Starting up RAID devices: " 

	rc=0
	
	for i in `grep "^raiddev" /etc/raidtab | awk '{print $2}'`
	do
		RAIDDEV=`basename $i`
                RAIDSTAT=`grep "^$RAIDDEV : active" /proc/mdstat`
		if [ -z "$RAIDSTAT" ]; then
			# Try raidstart first...if that fails then
			# fall back to raidadd, raidrun.  If that
			# also fails, then we drop to a shell
			RESULT=1
			if [ -x /sbin/raidstart ]; then
				/sbin/raidstart $i
				RESULT=$?
			fi
			if [ $RESULT -gt 0 -a -x /sbin/raid0run ]; then
				/sbin/raid0run $i
				RESULT=$?
			fi
			if [ $RESULT -gt 0 -a -x /sbin/raidadd -a -x /sbin/raidrun ]; then
				/sbin/raidadd $i
				/sbin/raidrun $i
				RESULT=$?
			fi
			if [ $RESULT -gt 0 ]; then
				rc=1
			fi
			echo -n "$RAIDDEV "
		else
			echo -n "$RAIDDEV "
		fi
	done
	echo

	# A non-zero return means there were problems.
	if [ $rc -gt 0 ]; then
		echo
		echo
		echo "*** An error occurred during the RAID startup"
		echo "*** Dropping you to a shell; the system will reboot"
		echo "*** when you leave the shell."

		PS1="(RAID Repair) \# # "; export PS1
		sulogin

		echo "Unmounting file systems"
		umount -a
		mount -n -o remount,ro /
		echo "Automatic reboot in progress."
		reboot -f
	fi
fi

_RUN_QUOTACHECK=0
# Check filesystems
if [ -z "$fastboot" ]; then
        STRING="Checking filesystems"
	echo $STRING
	initlog -c "fsck -T -R -A -a $fsckoptions"
	rc=$?
        if [ "$rc" = "0" ]; then
		success "$STRING"
		echo
	elif [ "$rc" = "1" ]; then
	        passed "$STRING"
		echo
	fi

	# A return of 2 or higher means there were serious problems.
	if [ $rc -gt 1 ]; then
	        failure "$STRING"
		echo
		echo
		echo "*** An error occurred during the file system check."
		echo "*** Dropping you to a shell; the system will reboot"
		echo "*** when you leave the shell."

		PS1="(Repair filesystem) \# # "; export PS1
		sulogin

		echo "Unmounting file systems"
		umount -a
		mount -n -o remount,ro /
		echo "Automatic reboot in progress."
		reboot -f
	elif [ "$rc" = "1" -a -x /sbin/quotacheck ]; then
		_RUN_QUOTACHECK=1
	fi
fi

# Mount all other filesystems (except for NFS and /proc, which is already
# mounted). Contrary to standard usage,
# filesystems are NOT unmounted in single user mode.
action "Mounting local filesystems: " mount -a -t nonfs,smbfs,ncpfs

if [ X"$_RUN_QUOTACHECK" = X1 -a -x /sbin/quotacheck ]; then
	action "Checking filesystem quotas: "  /sbin/quotacheck -v -R -a
fi

# Turn on process accounting
if [ -x /sbin/accton ] ; then
	action "Turning on process accounting" /sbin/accton /var/log/pacct
fi

# Configure machine if necessary.
if [ -f /.unconfigured ]; then
    if [ -x /usr/bin/passwd ]; then 
        /usr/bin/passwd root
    fi
    if [ -x /usr/sbin/netconfig ]; then
	/usr/sbin/netconfig
    fi
    if [ -x /usr/sbin/timeconfig ]; then
	/usr/sbin/timeconfig
    fi
    if [ -x /usr/sbin/authconfig ]; then
	/usr/sbin/authconfig --nostart
    fi
    if [ -x /usr/sbin/ntsysv ]; then
	/usr/sbin/ntsysv --level 35
    fi

    # Reread in network configuration data.
    if [ -f /etc/sysconfig/network ]; then
	. /etc/sysconfig/network

	# Reset the hostname.
	action "Resetting hostname ${HOSTNAME}: " hostname ${HOSTNAME}

	# Reset the NIS domain name.
	if [ -n "$NISDOMAIN" ]; then
	    action "Resetting NIS domain name $NISDOMAIN: " domainname $NISDOMAIN
	else
	    domainname ""
	fi
    fi

    rm -f /.unconfigured
fi

if [ -x /sbin/quotaon ]; then
    action "Turning on user and group quotas for local filesystems: " /sbin/quotaon -a
fi

# Clean out /etc.
rm -f /fastboot /fsckoptions /forcefsck /halt /poweroff

# Do we need (w|u)tmpx files? We don't set them up, but the sysadmin might...
_NEED_XFILES=
[ -f /var/run/utmpx -o -f /var/log/wtmpx ] && _NEED_XFILES=1

# Clean up /var
# I'd use find, but /usr may not be mounted.
for afile in /var/lock/* /var/run/*; do
   if [ -d "$afile" ]; then
      [ "`basename $afile`" != "news" -a "`basename $afile`" != "sudo" -a "`basename $afile`" != "mon" ] && rm -f $afile/*
   else
      rm -f $afile
   fi
done

# Reset pam_console permissions
[ -x /sbin/pam_console_apply ] && /sbin/pam_console_apply -r

{
# Clean up utmp/wtmp
>/var/run/utmp
touch /var/log/wtmp
chgrp utmp /var/run/utmp /var/log/wtmp
chmod 0664 /var/run/utmp /var/log/wtmp
if [ -n "$_NEED_XFILES" ]; then
  >/var/run/utmpx
  touch /var/log/wtmpx
  chgrp utmp /var/run/utmpx /var/log/wtmpx
  chmod 0664 /var/run/utmpx /var/log/wtmpx
fi

# Delete X locks
rm -f /tmp/.X*-lock

# Delete Postgres sockets
rm -f /tmp/.s.PGSQL.*

# Now turn on swap in case we swap to files.
swapon -a >/dev/null 2>&1
action "Enabling swap space: " /bin/true

# Initialize the serial ports.
if [ -f /etc/rc.serial ]; then
	. /etc/rc.serial
fi

# If a SCSI tape has been detected, load the st module unconditionally
# since many SCSI tapes don't deal well with st being loaded and unloaded
if [ -f /proc/scsi/scsi ] && grep -q 'Type:   Sequential-Access' /proc/scsi/scsi 2>/dev/null ; then
	if grep -qv ' 9 st' /proc/devices ; then
		if [ -n "$USEMODULES" ] ; then
			# Try to load the module.  If it fails, ignore it...
			insmod -p st >/dev/null 2>&1 && modprobe st >/dev/null 2>&1
		fi
	fi
fi

# Load usb storage here, to match most other things
if [ -n "$needusbstorage" ]; then
	modprobe usb-storage >/dev/null 2>&1
fi

# If they asked for ide-scsi, load it
if grep -q "ide-scsi" /proc/cmdline ; then
	modprobe ide-cd >/dev/null 2>&1
	modprobe ide-scsi >/dev/null 2>&1
fi

# Load agpgart here. This is a hack, and will probably go away soon.
if grep "driver: agpgart" /etc/sysconfig/hwconf >/dev/null 2>&1 ; then
	modprobe agpgart >/dev/null 2>&1
fi

# Generate a header that defines the boot kernel.
KERNEL_TYPE=`uname -r | sed 's_^[^se]*\(\|smp\|enterprise\)$_-\1_;s_^-$__'`
KERNEL_RELEASE=`uname -r | sed 's|smp\|enterprise||g'`

rpm -q kernel$KERNEL_TYPE-$KERNEL_RELEASE >/dev/null 2>&1 && KERNEL_ARCH=`rpm -q --qf '%{ARCH}' kernel$KERNEL_TYPE-$KERNEL_RELEASE 2>/dev/null` || KERNEL_ARCH=`uname -m`

OLD_KERNEL_ARCH_TYPE=`sed -n 's_^/\* Kernel type \(.*\) \*/_\1_p' /boot/kernel.h 2>/dev/null`
if [ -n "$KERNEL_ARCH" -a "$KERNEL_ARCH$KERNEL_TYPE" != "$OLD_KERNEL_ARCH_TYPE" ]; then
  ENTERPRISE='0'
  SMP='0'
  UP='0'
  case "$KERNEL_TYPE" in
  -smp) SMP='1';;
  -enterprise) ENTERPRISE='1';;
  *) UP='1';;
  esac
  cat > /boot/kernel.h << EOF
/* This file is automatically generated at boot time. */
#ifndef __BOOT_KERNEL_H_
#define __BOOT_KERNEL_H_

/* Kernel type $KERNEL_ARCH$KERNEL_TYPE */

#ifndef __MODULE_KERNEL_$KERNEL_ARCH
#define __MODULE_KERNEL_$KERNEL_ARCH 1
#endif

#ifndef __BOOT_KERNEL_ENTERPRISE
#define __BOOT_KERNEL_ENTERPRISE $ENTERPRISE
#endif

#ifndef __BOOT_KERNEL_SMP
#define __BOOT_KERNEL_SMP $SMP
#endif

#ifndef __BOOT_KERNEL_UP
#define __BOOT_KERNEL_UP $UP
#endif

#endif
EOF
fi

# Adjust symlinks as necessary in /boot to keep system services from
# spewing messages about mismatched System maps and so on.
if [ -L /boot/System.map -a -r /boot/System.map-`uname -r` ] ; then
	ln -s -f System.map-`uname -r` /boot/System.map
fi
if [ ! -e /boot/System.map -a -r /boot/System.map-`uname -r` ] ; then
	ln -s -f System.map-`uname -r` /boot/System.map
fi

# Now that we have all of our basic modules loaded and the kernel going,
# let's dump the syslog ring somewhere so we can find it later
dmesg > /var/log/dmesg
sleep 1
kill -TERM `/sbin/pidof getkey` >/dev/null 2>&1
} &
if [ "$PROMPT" != "no" ]; then
   /sbin/getkey i && touch /var/run/confirm
fi
wait
