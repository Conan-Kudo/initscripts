# -*-Shell-script-*-
#
# functions	This file contains functions to be used by most or all
#		shell scripts in the /etc/init.d directory.
#

TEXTDOMAIN=initscripts
TEXTDOMAINDIR=/etc/locale

# Make sure umask is sane
umask 022

# Set up a default search path.
PATH="/sbin:/usr/sbin:/bin:/usr/bin:/usr/X11R6/bin"
export PATH

# Get a sane screen width
[ -z "${COLUMNS:-}" ] && COLUMNS=80

[ -z "${CONSOLETYPE:-}" ] && CONSOLETYPE="`/sbin/consoletype`"

if [ -f /etc/sysconfig/i18n -a -z "${NOLOCALE:-}" ] ; then
  . /etc/sysconfig/i18n
  if [ "$CONSOLETYPE" != "pty" ]; then
	case "${LANG:-}" in
		ja_JP.eucJP|ko_KR.eucKR|zh_CN.GB2312|zh_TW.Big5|zh_CN.GB18030)
			unset LANG;;
		*)
			export LANG
	esac
  else
	export LANG
  fi
fi

# Read in our configuration
if [ -z "${BOOTUP:-}" ]; then
  if [ -f /etc/sysconfig/init ]; then
      . /etc/sysconfig/init
  else
    # This all seem confusing? Look in /etc/sysconfig/init,
    # or in /usr/doc/initscripts-*/sysconfig.txt
    BOOTUP=color
    RES_COL=60
    MOVE_TO_COL="echo -en \\033[${RES_COL}G"
    SETCOLOR_SUCCESS="echo -en \\033[1;32m"
    SETCOLOR_FAILURE="echo -en \\033[1;31m"
    SETCOLOR_WARNING="echo -en \\033[1;33m"
    SETCOLOR_NORMAL="echo -en \\033[0;39m"
    LOGLEVEL=1
  fi
  if [ "$CONSOLETYPE" = "serial" ]; then
      BOOTUP=serial
      MOVE_TO_COL=
      SETCOLOR_SUCCESS=
      SETCOLOR_FAILURE=
      SETCOLOR_WARNING=
      SETCOLOR_NORMAL=
  fi
fi

if [ "${BOOTUP:-}" != "verbose" ]; then
   INITLOG_ARGS="-q"
else
   INITLOG_ARGS=
fi

# Check if $pid (could be plural) are running
checkpid() {
	local i

	for i in $* ; do
		[ -d "/proc/$i" ] && return 0
	done
	return 1
}
	

# A function to start a program.
daemon() {
	# Test syntax.
	local gotbase= force=
	local base= user= nice= bg= pid=
	nicelevel=0
	while [ "$1" != "${1##[-+]}" ]; do
	  case $1 in
	    '')    echo $"$0: Usage: daemon [+/-nicelevel] {program}"
	           return 1;;
	    --check)
		   base=$2
		   gotbase="yes"
		   shift 2
		   ;;
	    --check=?*)
	    	   base=${1#--check=}
		   gotbase="yes"
		   shift
		   ;;
	    --user)
		   user=$2
		   shift 2
		   ;;
	    --user=?*)
	           user=${1#--user=}
		   shift
		   ;;
	    --force)
	    	   force="force"
		   shift
		   ;;
	    [-+][0-9]*)
	    	   nice="nice -n $1"
	           shift
		   ;;
	    *)     echo $"$0: Usage: daemon [+/-nicelevel] {program}"
	           return 1;;
	  esac
	done

        # Save basename.
        [ -z "$gotbase" ] && base=${1##*/}

        # See if it's already running. Look *only* at the pid file.
	if [ -f /var/run/${base}.pid ]; then
		local line p
		read line < /var/run/${base}.pid
		for p in $line ; do
			[ -z "${p//[0-9]/}" -a -d "/proc/$p" ] && pid="$pid $p"
		done
	fi
	
	[ -n "${pid:-}" -a -z "${force:-}" ] && return

	# make sure it doesn't core dump anywhere; while this could mask
	# problems with the daemon, it also closes some security problems
	ulimit -S -c 0 >/dev/null 2>&1
	
	# Echo daemon
        [ "${BOOTUP:-}" = "verbose" -a -z "$LSB" ] && echo -n " $base"

	# And start it up.
	if [ -z "$user" ]; then
	   $nice initlog $INITLOG_ARGS -c "$*"
	else
	   $nice initlog $INITLOG_ARGS -c "su -s /bin/bash - $user -c \"$*\""
	fi
	[ "$?" -eq 0 ] && success $"$base startup" || failure $"$base startup"
}

# A function to stop a program.
killproc() {
	RC=0
	# Test syntax.
	if [ "$#" -eq 0 ]; then
		echo $"Usage: killproc {program} [signal]"
		return 1
	fi

	notset=0
	# check for second arg to be kill level
	if [ -n "$2" ]; then
		killlevel=$2
	else
		notset=1
		killlevel="-9"
	fi

        # Save basename.
        base=${1##*/}

        # Find pid.
	pid=
	if [ -f /var/run/${base}.pid ]; then
		local line p
		read line < /var/run/${base}.pid
		for p in $line ; do
			[ -z "${p//[0-9]/}" -a -d "/proc/$p" ] && pid="$pid $p"
		done
	fi
	if [ -z "$pid" ]; then
		pid=`pidof -o $$ -o $PPID -o %PPID -x $1 || \
			pidof -o $$ -o $PPID -o %PPID -x $base`
	fi

        # Kill it.
        if [ -n "${pid:-}" ] ; then
                [ "$BOOTUP" = "verbose" -a -z "$LSB" ] && echo -n "$base "
		if [ "$notset" -eq "1" ] ; then
		       if checkpid $pid 2>&1; then
			   # TERM first, then KILL if not dead
			   kill -TERM $pid
			   usleep 100000
			   if checkpid $pid && sleep 1 &&
			      checkpid $pid && sleep 3 &&
			      checkpid $pid ; then
                                kill -KILL $pid
				usleep 100000
			   fi
		        fi
			checkpid $pid
			RC=$?
			[ "$RC" -eq 0 ] && failure $"$base shutdown" || success $"$base shutdown"
			RC=$((! $RC))
		# use specified level only
		else
		        if checkpid $pid; then
	                	kill $killlevel $pid
				RC=$?
				[ "$RC" -eq 0 ] && success $"$base $killlevel" || failure $"$base $killlevel"
			fi
		fi
	else
	    failure $"$base shutdown"
	    RC=1
	fi

        # Remove pid file if any.
	if [ "$notset" = "1" ]; then
            rm -f /var/run/$base.pid
	fi
	return $RC
}

# A function to find the pid of a program. Looks *only* at the pidfile
pidfileofproc() {
	local base=${1##*/}
	
	# Test syntax.
	if [ "$#" = 0 ] ; then
		echo $"Usage: pidfileofproc {program}"
		return 1
	fi

	# First try "/var/run/*.pid" files
	if [ -f /var/run/$base.pid ] ; then
	        local line p pid=
		read line < /var/run/$base.pid
		for p in $line ; do
		       [ -z "${p//[0-9]/}" -a -d /proc/$p ] && pid="$pid $p"
		done
	        if [ -n "$pid" ]; then
	                echo $pid
	                return 0
	        fi
	fi
}

# A function to find the pid of a program.
pidofproc() {
	base=${1##*/}

	# Test syntax.
	if [ "$#" = 0 ]; then
		echo $"Usage: pidofproc {program}"
		return 1
	fi

	# First try "/var/run/*.pid" files
	if [ -f /var/run/$base.pid ]; then
	        local line p pid=
		read line < /var/run/$base.pid
		for p in $line ; do
		       [ -z "${p//[0-9]/}" -a -d /proc/$p ] && pid="$pid $p"
		done
	        if [ -n "$pid" ]; then
	                echo $pid
	                return 0
	        fi
	fi
	pidof -o $$ -o $PPID -o %PPID -x $1 || \
		pidof -o $$ -o $PPID -o %PPID -x $base
}

status() {
	local base=${1##*/}
	local pid

	# Test syntax.
	if [ "$#" = 0 ] ; then
		echo $"Usage: status {program}"
		return 1
	fi

	# First try "pidof"
	pid=`pidof -o $$ -o $PPID -o %PPID -x $1 || \
	     pidof -o $$ -o $PPID -o %PPID -x ${base}`
	if [ -n "$pid" ]; then
	        echo $"${base} (pid $pid) is running..."
	        return 0
	fi

	# Next try "/var/run/*.pid" files
	if [ -f /var/run/${base}.pid ] ; then
	        read pid < /var/run/${base}.pid
	        if [ -n "$pid" ]; then
	                echo $"${base} dead but pid file exists"
	                return 1
	        fi
	fi
	# See if /var/lock/subsys/${base} exists
	if [ -f /var/lock/subsys/${base} ]; then
		echo $"${base} dead but subsys locked"
		return 2
	fi
	echo $"${base} is stopped"
	return 3
}

echo_success() {
  [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
  echo -n "[  "
  [ "$BOOTUP" = "color" ] && $SETCOLOR_SUCCESS
  echo -n $"OK"
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  echo -n "  ]"
  echo -ne "\r"
  return 0
}

echo_failure() {
  [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
  echo -n "["
  [ "$BOOTUP" = "color" ] && $SETCOLOR_FAILURE
  echo -n $"FAILED"
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  echo -n "]"
  echo -ne "\r"
  return 1
}

echo_passed() {
  [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
  echo -n "["
  [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
  echo -n $"PASSED"
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  echo -n "]"
  echo -ne "\r"
  return 1
}

echo_warning() {
  [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
  echo -n "["
  [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
  echo -n $"WARNING"
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  echo -n "]"
  echo -ne "\r"
  return 1
}

# Log that something succeeded
success() {
  if [ -z "${IN_INITLOG:-}" ]; then
     initlog $INITLOG_ARGS -n $0 -s "$1" -e 1
  else
     # silly hack to avoid EPIPE killing rc.sysinit
     trap "" SIGPIPE
     echo "$INITLOG_ARGS -n $0 -s \"$1\" -e 1" >&21
     trap - SIGPIPE
  fi
  [ "$BOOTUP" != "verbose" -a -z "$LSB" ] && echo_success
  return 0
}

# Log that something failed
failure() {
  rc=$?
  if [ -z "${IN_INITLOG:-}" ]; then
     initlog $INITLOG_ARGS -n $0 -s "$1" -e 2
  else
     trap "" SIGPIPE
     echo "$INITLOG_ARGS -n $0 -s \"$1\" -e 2" >&21
     trap - SIGPIPE
  fi
  [ "$BOOTUP" != "verbose" -a -z "$LSB" ] && echo_failure
  return $rc
}

# Log that something passed, but may have had errors. Useful for fsck
passed() {
  rc=$?
  if [ -z "${IN_INITLOG:-}" ]; then
     initlog $INITLOG_ARGS -n $0 -s "$1" -e 1
  else
     trap "" SIGPIPE
     echo "$INITLOG_ARGS -n $0 -s \"$1\" -e 1" >&21
     trap - SIGPIPE
  fi
  [ "$BOOTUP" != "verbose" -a -z "$LSB" ] && echo_passed
  return $rc
}  

# Log a warning
warning() {
  rc=$?
  if [ -z "${IN_INITLOG:-}" ]; then
     initlog $INITLOG_ARGS -n $0 -s "$1" -e 1
  else
     trap "" SIGPIPE
     echo "$INITLOG_ARGS -n $0 -s \"$1\" -e 1" >&21
     trap - SIGPIPE
  fi
  [ "$BOOTUP" != "verbose" -a -z "$LSB" ] && echo_warning
  return $rc
}  

# Run some action. Log its output.
action() {
  STRING=$1
  echo -n "$STRING "
  shift
  initlog $INITLOG_ARGS -c "$*" && success $"$STRING" || failure $"$STRING"
  rc=$?
  echo
  return $rc
}


# bgaction()
# A replacement for action() that runs the script arguments in
# the background.
#
# I have a vague worry about a subtle race condition lurking
# both here and in the regular non-serel boot.  initlog's
# behaviour apepars undefined unless syslog has started, so what
# about when this routine gets called prior to syslog starting?
# Must investigate further!
#
bgaction() {
    STRING=$1
    echo -n "$STRING "
    shift
    /bin/bash -s << END &
. /etc/init.d/functions
initlog $INITLOG_ARGS -c "serel-wrap $*" && \
    success $"$STRING" || failure $"$STRING"
rc=$?
echo
exit $rc
END
}


# returns OK if $1 contains $2
strstr() {
	#case "$1" in
	#	*${2}*)	return 0 ;;
	#esac
	#return 1
  [ "$1" = "$2" ] && return 0
  slice=${1#*$2*}
  [ "$slice" = "$1" ] && return 1
  return 0
}

# Confirm whether we really want to run this service
confirm() {
  local YES=$"yY"
  local NO=$"nN"
  local CONT=$"cC"
  
  while : ; do 
      echo -n $"Start service $1 (Y)es/(N)o/(C)ontinue? [Y] "
      read answer
      if strstr "$YES" "$answer" || [ "$answer" = "" ] ; then
         return 0
      elif strstr "$CONT" "$answer" ; then
         return 2
      elif strstr "$NO" "$answer" ; then
         return 1
      fi
  done
}

# check a file to be a correct runlevel script
check_runlevel ()
{
        # Check if the file exists at all.
        [ -x "$1" ] || return 1

        # Reject backup files and files generated by rpm.
        case "$1" in
                *.rpmsave|*.rpmorig|*.rpmnew|*~|*.orig)
                        return 1
                        ;;
        esac
        return 0
}



# toggle if 'serel' was passed on the boot line
#
serel_boot_toggle() {
    if grep -i serel /proc/cmdline >/dev/null; then
	
        if [ $SEREL_BOOT = "yes" ]; then
            SEREL_BOOT="no"
        else
            SEREL_BOOT="yes"
        fi
    fi
}

serel_start_populate_validate() {
    [ "$SEREL_BOOT" = "yes" ] && sereld -b $SERELD_OPTIONS

    [ "$SEREL_BOOT" = "yes" -a $? != "0" ] && SEREL_BOOT="no"

    # tell the daemon what's started and what's about to start
    if [ "$SEREL_BOOT" = "yes" ]; then
        serelhistory --populate <<EOF
--started
$SEREL_STARTED
--pairs
$SEREL_PAIRS
EOF
    fi

    [ "$SEREL_BOOT" = "yes" -a $? != "0" ] && \
        SEREL_BOOT="no" && serelc --control stop

    [ "$SEREL_BOOT" = "yes" ] && \
        serelhistory --query verify | grep "success" 2>&1 > /dev/null

    [ "$SEREL_BOOT" = "yes" -a $? != "0" ] && \
        SEREL_BOOT="no" && serelc --control stop
}

# Use serel to start in parallel?
#
redhat_sysvinit_start () {
SEREL_BOOT=no

# 0, 1 and 6 don't need serel
#
if [ "$CONFIRM" != "yes" ] && [ $runlevel = "2" -o $runlevel = "3" -o $runlevel = "4" -o $runlevel = "5" ]; then
    # also check the kernel command line
    serel_boot_toggle

    [ -f /usr/bin/sereld ] || SEREL_BOOT="no"
fi

if [ "$SEREL_BOOT" = "yes" ]; then
    # Work out what's already started, and what's about to start
    #
    SEREL_STARTED=
    SEREL_PAIRS=

    for i in /etc/rc$runlevel.d/S*; do
        check_runlevel "$i" || continue

        # build the arguments to --populate

        # Check if the subsystem is already up.
        subsys=${i#/etc/rc$runlevel.d/S??}

        # fall back to non-serel boot in these cases
        if [ "$subsys" = "halt" -o "$subsys" = "reboot" -o "$subsys" = "single" ]; then
            SEREL_BOOT=
            break;
        fi

        if [ -f /var/lock/subsys/$subsys -o \
	    -f /var/lock/subsys/${subsys}.init ]; then
	    # Add subsystem to already started list
	    SEREL_STARTED="$SEREL_STARTED $subsys"
	    continue;
	fi

	# If we're in confirmation mode, get user confirmation
	if [ -n "$CONFIRM" ]; then
	    confirm $subsys
	    case $? in
		0) :;;
		2) CONFIRM=;;
		*) continue;;
	    esac
	fi
	
        SEREL_PAIRS="$SEREL_PAIRS $subsys $i"
    done
fi

serel_start_populate_validate

if [ "$SEREL_BOOT" = "yes" ]; then
    # can't fall back to normal-boot now, we're going with serel
    #
    serelhistory --apply-started

    toggle="service"

    for i in $SEREL_PAIRS; do
        if [ "$toggle" = "service" ]; then
            toggle="path"
            subsys=$i
            continue
        else
            toggle="service"
            path=$i
        fi

        egrep -q "(daemon |action )" $path

        if [ $? = "0" -o "$subsys" = "local" ]; then
            serel-wrap $path start &
        else

            bgaction $"Starting $subsys: " $path start
        fi
    done

    wait

    # No need to generate a new graph if --populate reused an old history.
    #
    serelhistory --query prior-history | grep -v "success" 2>&1 > /dev/null
    [ -n "$SEREL_GENERATE_RDF" -a $? = "0" ] && serel-rdfgen > $SEREL_GENERATE_RDF

    serelc --control stop
fi
}
